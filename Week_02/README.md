
#### Hash表、映射、集合
1. 哈希表查询速度快，但需要额外的空间，常用于空间换时间。
1. 哈希碰撞比较好的解决办法是增加一个维度:拉链式冲突||红黑树。
1. HashSet 和 HashMap 的底层结构为哈希表，java中HashSet是基于HashMap实现的。
1. TreeSet 和 TreeMap 的底层结构为红黑树，存储的数据时有序的。


#### 树 堆
1. 链表是特殊的树，树是特殊的图。链表多几个节点就是树，树有环就是图。
1. 二叉搜索树是有序的二叉树，左树的所有节点都小于根节点，右树的所有节点都大于根节点。
1. 根节点最大的堆叫大顶堆，根节点最小的堆叫小顶堆。
1. 堆有很多种，二叉堆、裴波拉契堆等，二叉堆的时间复杂度在堆中是最差的,但是它实现简单,常在面试中考察。
1. 二叉堆是根据完全二叉树实现的，父节点的值大于等于儿子节点的值。
1. java中常用PriorityQueue作为堆的实现，默认为自然顺序排序。

#### HashMap 源码分析(基于 Java 1.8)

1. HashMap 采用数组 + 链表/红黑树的方式存储元素，当链表的结点数大于等于7时，转换为红黑树。
##### put() 操作
1. 通过((n - 1) & hash)计算当前节点存放在 table 数组的索引位置，如果该位置当前为空，直接将结点放到此位置。
1. 如果不为空，判断当前位置的结点是否与新插入的结点 key 相同。如果是，取得该结点。
1. 如果不是，则搜索链表或者红黑树，若搜不到，则插入链表或者红黑树，需判断是否需要扩容，链表如果大于等于7时，需要转换为红黑树
1. 若搜到，则用新的值替换旧值，返回null.


##### get(key) 操作
1. 通过((n - 1) & hash)求出指定 key存放在 table 数组的索引位置，获取到该位置上的第一个结点。
1. 判断第一个结点的 key 是否与指定 key 相同，相同则返回该结点。
1. 否则，搜索链表或者红黑树
1. 如果最终没找到，返回 null。